<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 8.1.1">
<link rel="preconnect" href="https://fonts.googleapis.com" crossorigin>
<link rel="preconnect" href="https://cdnjs.cloudflare.com" crossorigin>
  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/blog/images/logo.svg" color="#222">
  <meta name="google-site-verification" content="IT-Y25F5RCj2PCcER-kk9d5-HNubsC889CdBMXmjtZY">
  <meta name="msvalidate.01" content="B87806C7BDCEE73E30D63422AFE6515C">

<link rel="stylesheet" href="/blog/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/7.0.0/css/all.min.css" integrity="sha256-VHqXKFhhMxcpubYf9xiWdCiojEbY9NexQ4jh8AxbvcM=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.css" integrity="sha256-gkQVf8UKZgQ0HyuxL/VnacadJ+D2Kox2TCEBuNQg5+w=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/themes/black/pace-theme-minimal.css">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pace/1.2.4/pace.min.js" integrity="sha256-gqd7YTjg/BtfqWSwsJOvndl0Bxc8gFImLEkXQT8+qj0=" crossorigin="anonymous" defer></script>

<script class="next-config" data-name="main" type="application/json">{"hostname":"afetmin.github.io","root":"/blog/","images":"/blog/images","scheme":"Pisces","darkmode":false,"version":"8.26.0","exturl":true,"sidebar":{"position":"right","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"codeblock":{"theme":{"light":"atom-one-light","dark":"atom-one-dark"},"prism":{"light":"prism","dark":"prism-one-dark"},"copy_button":{"enable":true,"style":"flat"},"fold":{"enable":true,"height":400},"language":false},"bookmark":{"enable":false,"color":"#222","save":"manual"},"mediumzoom":false,"lazyload":true,"pangu":true,"comments":{"style":"tabs","active":"utterances","storage":true,"lazyload":false,"nav":null,"activeClass":"utterances"},"stickytabs":false,"motion":{"enable":true,"async":true,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/blog/search.json","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":true,"trigger":"auto"}}</script><script src="/blog/js/config.js" defer></script>



<link rel="canonical" href="https://afetmin.github.io/blog/JavaScript%20%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%EF%BC%9AShapes%20%E5%92%8C%20Inline%20Caches/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":true,"permalink":"https://afetmin.github.io/blog/JavaScript%20%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%EF%BC%9AShapes%20%E5%92%8C%20Inline%20Caches/","path":"JavaScript 引擎基础：Shapes 和 Inline Caches/","title":"JavaScript 引擎基础：Shapes 和 Inline Caches"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>JavaScript 引擎基础：Shapes 和 Inline Caches | DevDino 🦖</title>
  
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-CCDJNF04LD"></script>
  <script class="next-config" data-name="google_analytics" type="application/json">{"tracking_id":"G-CCDJNF04LD","only_pageview":false,"measure_protocol_api_secret":null}</script>
  <script src="/blog/js/third-party/analytics/google-analytics.js" defer></script>

  <script src="/blog/js/third-party/analytics/baidu-analytics.js" defer></script>
  <script async src="https://hm.baidu.com/hm.js?d3c4bbd29d7df929e988a67667b6fe6e"></script>







  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.6.0/pjax.min.js" integrity="sha256-vxLn1tSKWD4dqbMRyv940UYw4sXgMtYcK6reefzZrao=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/fancyapps-ui/5.0.31/fancybox/fancybox.umd.js" integrity="sha256-a+H7FYzJv6oU2hfsfDGM2Ohw/cR9v+hPfxHCLdmCrE8=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/lozad.js/1.16.0/lozad.min.js" integrity="sha256-mOFREFhqmHeQbXpK2lp4nA3qooVgACfh88fpJftLBbc=" crossorigin="anonymous" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pangu/7.2.0/pangu.umd.js" integrity="sha256-JnmRRnJK7DC6RQJbAJb6AXOM9OmWzS6z8eYultk/48Y=" crossorigin="anonymous" defer></script>
<script src="/blog/js/utils.js" defer></script><script src="/blog/js/motion.js" defer></script><script src="/blog/js/sidebar.js" defer></script><script src="/blog/js/next-boot.js" defer></script><script src="/blog/js/pjax.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.5.0/search.js" integrity="sha256-xFC6PJ82SL9b3WkGjFavNiA9gm5z6UBxWPiu4CYjptg=" crossorigin="anonymous" defer></script>
<script src="/blog/js/third-party/search/local-search.js" defer></script>




  <script src="/blog/js/third-party/fancybox.js" defer></script>

  <script src="/blog/js/third-party/pace.js" defer></script>


  




  

  <script class="next-config" data-name="enableMath" type="application/json">true</script><script class="next-config" data-name="mathjax" type="application/json">{"enable":true,"tags":"ams","js":{"url":"https://cdnjs.cloudflare.com/ajax/libs/mathjax/3.2.2/es5/tex-mml-chtml.js","integrity":"sha256-MASABpB4tYktI2Oitl4t+78w/lyA+D7b/s9GEP0JOGI="}}</script>
<script src="/blog/js/third-party/math/mathjax.js" defer></script>


  <script src="https://cdnjs.cloudflare.com/ajax/libs/quicklink/3.0.1/quicklink.umd.js" integrity="sha256-44BednzIpUeQJcY8qtLyarFu0UCCTbgmWOvaoehiFQQ=" crossorigin="anonymous" defer></script>
  <script class="next-config" data-name="quicklink" type="application/json">{"enable":true,"home":false,"archive":false,"delay":true,"timeout":2000,"priority":true,"url":"https://afetmin.github.io/blog/JavaScript%20%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%EF%BC%9AShapes%20%E5%92%8C%20Inline%20Caches/"}</script>
  <script src="/blog/js/third-party/quicklink.js" defer></script>


    

<link rel='stylesheet' href='https://chinese-fonts-cdn.deno.dev/packages/lxgwwenkai/dist/lxgwwenkai-light/result.css' /> 

<script defer src="https://cloud.umami.is/script.js" data-website-id="f7e43abb-be35-494a-8984-2586daf37f19"></script>

  <noscript>
    <link rel="stylesheet" href="/blog/css/noscript.css">
  </noscript>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/blog/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">DevDino 🦖</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">我曾七次鄙视自己的灵魂</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/blog/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/blog/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/blog/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">8</span></a></li><li class="menu-item menu-item-categories"><a href="/blog/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">11</span></a></li><li class="menu-item menu-item-archives"><a href="/blog/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">87</span></a></li><li class="menu-item menu-item-sitemap"><a href="/blog/sitemap.xml" rel="section"><i class="fa fa-sitemap fa-fw"></i>站点地图</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#1-JavaScript-%E5%BC%95%E6%93%8E%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B"><span class="nav-number">1.</span> <span class="nav-text">1. JavaScript 引擎工作流程</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#1-1-JavaScript-%E5%BC%95%E6%93%8E%E4%B8%AD%E7%9A%84%E8%A7%A3%E9%87%8A%E5%99%A8-%E7%BC%96%E8%AF%91%E5%99%A8%E6%B5%81%E7%A8%8B"><span class="nav-number">1.1.</span> <span class="nav-text">1.1 JavaScript 引擎中的解释器&#x2F;编译器流程</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-JavaScript-%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B"><span class="nav-number">2.</span> <span class="nav-text">2. JavaScript 对象模型</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E5%B1%9E%E6%80%A7%E8%AE%BF%E9%97%AE%E7%9A%84%E4%BC%98%E5%8C%96"><span class="nav-number">3.</span> <span class="nav-text">3. 属性访问的优化</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-Shapes"><span class="nav-number">3.1.</span> <span class="nav-text">3.1 Shapes</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-2-Transition-%E9%93%BE%E4%B8%8E%E6%A0%91"><span class="nav-number">4.</span> <span class="nav-text">3.2 Transition 链与树</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Inline-Caches-ICs"><span class="nav-number">4.1.</span> <span class="nav-text">3.3 Inline Caches (ICs)</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E9%AB%98%E6%95%88%E5%AD%98%E5%82%A8%E6%95%B0%E7%BB%84"><span class="nav-number">5.</span> <span class="nav-text">4. 高效存储数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Take-aways"><span class="nav-number">6.</span> <span class="nav-text">5. Take-aways</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="Rion"
      src="/blog/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">Rion</p>
  <div class="site-description" itemprop="description">人生苦短，何必荒废时光去遗憾？</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/blog/archives/">
          <span class="site-state-item-count">87</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/blog/categories/">
        <span class="site-state-item-count">11</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/blog/tags/">
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2FmZXRtaW4=" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;afetmin"><i class="fab fa-github fa-fw"></i>GitHub</span>
      </span>
      <span class="links-of-author-item">
        <span class="exturl" data-url="bWFpbHRvOmtpbmdwZW5ndWluc0AxNjMuY29t" title="E-Mail → mailto:kingpenguins@163.com"><i class="fa fa-envelope fa-fw"></i>E-Mail</span>
      </span>
  </div>
  <div class="cc-license animated" itemprop="license">
    <span class="exturl cc-opacity" data-url="aHR0cHM6Ly9jcmVhdGl2ZWNvbW1vbnMub3JnL2xpY2Vuc2VzL2J5LW5jLXNhLzQuMC96aC1DTg=="><img src="https://cdnjs.cloudflare.com/ajax/libs/creativecommons-vocabulary/2020.11.3/assets/license_badges/small/by_nc_sa.svg" alt="Creative Commons"></span>
  </div>

        </div>
      </div>
        <div class="back-to-top animated" role="button" aria-label="返回顶部">
          <i class="fa fa-arrow-up"></i>
          <span>0%</span>
        </div>
    </div>

    
        <div class="pjax">
        <div class="sidebar-inner sidebar-post-related">
          <div class="animated">
              <div class="links-of-blogroll-title"><i class="fa fa-signs-post fa-fw"></i>
    相关文章
  </div>
  <ul class="popular-posts">
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/blog/19%20%E9%81%BF%E5%85%8D%20NumPy%20%E4%B8%AD%E7%9A%84%E2%80%9C%E7%A7%A91%E6%95%B0%E7%BB%84%E2%80%9D%EF%BC%88Rank-1%20Array%EF%BC%89%E9%99%B7%E9%98%B1/" rel="bookmark">
        <time class="popular-posts-time">2025-12-15</time>
        <br>
      19 避免 NumPy 中的“秩1数组”（Rank-1 Array）陷阱
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/blog/%E5%A4%8D%E7%8E%B0musicForProgramming%E7%BD%91%E7%AB%99%E7%9A%84%E9%9F%B3%E4%B9%90%E5%8F%AF%E8%A7%86%E5%8C%96%E6%95%88%E6%9E%9C/" rel="bookmark">
        <time class="popular-posts-time">2025-02-28</time>
        <br>
      复现 musicforprogramming.net 的音乐可视化效果
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/blog/%E7%AC%AC%E4%B8%89%E7%AB%A0%EF%BC%9A%E5%8F%98%E6%8D%A2/" rel="bookmark">
        <time class="popular-posts-time">2023-04-01</time>
        <br>
      第三章：变换
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/blog/%E7%AC%AC%E5%8D%81%E5%85%AD%E7%AB%A0%EF%BC%9ARay%20tracing4%20%E8%92%99%E7%89%B9%E5%8D%A1%E6%B4%9B%E8%B7%AF%E5%BE%84%E8%BF%BD%E8%B8%AA/" rel="bookmark">
        <time class="popular-posts-time">2023-08-17</time>
        <br>
      第十六章：Ray tracing4 蒙特卡洛路径追踪
      </a>
    </li>
    <li class="popular-posts-item">
      <a class="popular-posts-link" href="/blog/%E7%AC%AC%E4%BA%8C%E5%8D%81%E7%AB%A0%EF%BC%9A%E9%A2%9C%E8%89%B2%E5%92%8C%E6%84%9F%E7%9F%A5/" rel="bookmark">
        <time class="popular-posts-time">2023-08-17</time>
        <br>
      第二十章：颜色和感知
      </a>
    </li>
  </ul>

          </div>
        </div>
        </div>
  </aside>


    </div>

    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://afetmin.github.io/blog/JavaScript%20%E5%BC%95%E6%93%8E%E5%9F%BA%E7%A1%80%EF%BC%9AShapes%20%E5%92%8C%20Inline%20Caches/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/blog/images/avatar.jpg">
      <meta itemprop="name" content="Rion">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="DevDino 🦖">
      <meta itemprop="description" content="人生苦短，何必荒废时光去遗憾？">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="JavaScript 引擎基础：Shapes 和 Inline Caches | DevDino 🦖">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          JavaScript 引擎基础：Shapes 和 Inline Caches
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2025-07-31 19:57:03" itemprop="dateCreated datePublished" datetime="2025-07-31T19:57:03+00:00">2025-07-31</time>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>4.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody"><p>本文就所有 JavaScript 引擎中常见的一些关键基础内容进行了介绍——这不仅仅局限于 V8 引擎。作为一名 JavaScript 开发者，深入了解 JavaScript 引擎是如何工作的将有助于你了解自己所写代码的性能特征。关于本文，全文共由五个部分组成：</p>
<ol>
<li>​<strong>JavaScript 引擎工作流程</strong>​：介绍 JavaScript 引擎的处理流水线，这一部分会涉及到解释器／编译器的内容，且会分点介绍不同引擎间的差别与共同点；</li>
<li>​<strong>JavaScript 对象模型</strong>​；</li>
<li>​<strong>属性访问的优化</strong>​：通过 Shapes、Transistion 链与树、ICs 等概念的穿插介绍引擎是如何优化获取对象属性的；</li>
<li>​<strong>高效存储数组</strong>​；</li>
<li>​<strong>Take-aways</strong>​：对全文内容做了一个小结，并给了两点建议。</li>
</ol>
<p>　　原文 <span class="exturl" data-url="aHR0cHM6Ly9tYXRoaWFzYnluZW5zLmJlL25vdGVzL3NoYXBlcy1pY3M=">JavaScript engine fundamentals: Shapes and Inline Caches<i class="fa fa-external-link-alt"></i></span>，作者 <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9ibWV1cmVy">@Benedikt<i class="fa fa-external-link-alt"></i></span> 和 <span class="exturl" data-url="aHR0cHM6Ly90d2l0dGVyLmNvbS9tYXRoaWFz">@Mathias<i class="fa fa-external-link-alt"></i></span>，译者 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL2hpamlhbmd0YW8=">hijiangtao<i class="fa fa-external-link-alt"></i></span>。</p>
<blockquote>
<p>如果你倾向看视频演讲，请移步 <span class="exturl" data-url="aHR0cHM6Ly93d3cueW91dHViZS5jb20vZW1iZWQvNW5tcG9rb1JhWkk=">YouTube<i class="fa fa-external-link-alt"></i></span> 查看更多。</p>
</blockquote>
<h2 id="1-JavaScript-引擎工作流程"><a href="#1-JavaScript-引擎工作流程" class="headerlink" title="1. JavaScript 引擎工作流程"></a>1. JavaScript 引擎工作流程</h2><p>　　这一切都得从你所写的 JavaScript 代码开始说起。JavaScript 引擎在解析源码后将其转换为抽象语法树（AST）。基于 AST，解释器便可以开始工作并产生字节码。非常棒！此时引擎正在执行 JavaScript 代码。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-1-20250731195703-lfum55d.svg">​</p>
<p>　　为了使它执行得更快，可以将字节码与分析数据（profiling data）一起发给优化编译器。优化编译器根据已有的分析数据做出特定假设，然后生成高度优化的机器码。</p>
<p>　　如果在某点上一个假设被证明是不正确的，那么优化编译器会<strong>去优化</strong>并回退至解释器部分。</p>
<h3 id="1-1-JavaScript-引擎中的解释器-编译器流程"><a href="#1-1-JavaScript-引擎中的解释器-编译器流程" class="headerlink" title="1.1 JavaScript 引擎中的解释器&#x2F;编译器流程"></a>1.1 JavaScript 引擎中的解释器&#x2F;编译器流程</h3><p>　　现在，让我们关注实际执行 JavaScript 代码的这部分流程，即代码被解释和优化的地方，并讨论其在主要的 JavaScript 引擎之间存在的一些差异。</p>
<p>　　一般来说，（所有 JavaSciript 引擎）都有一个包含解释器和优化编译器的处理流程。其中，解释器可以快速生成未优化的字节码，而优化编译器会需要更长的时间，以便最终生成高度优化的机器码。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-2-20250731195703-o1810gl.svg">​</p>
<p>　　这个通用流程几乎与在 Chrome 和 Node.js 中使用的 V8 引擎工作流程一致：</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-3-20250731195703-h5g7tbi.svg">​</p>
<p>　　V8 中的解释器被称作 Ignition，它负责生成并执行字节码。当它运行字节码时会收集分析数据，而它之后可以被用于加快（代码）执行的速度。当一个函数变得 ​<em>hot</em>​，例如它经常被调用，生成的字节码和分析数据则会被传给 TurboFan——我们的优化编译器，它会依据分析数据生成高度优化的机器码。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-4-20250731195703-bvqiple.svg">​</p>
<p>　　SpiderMonkey，在 Firefox 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL21vemlsbGEvc3BpZGVybm9kZQ==">SpiderNode<i class="fa fa-external-link-alt"></i></span> 中使用的 Mozilla 的 JavaScript 引擎，则有一些不同的地方。它们有两个优化编译器。解释器将代码解释给 Baseline 编译器，该编译器可以生成部分优化的代码。 结合运行代码时收集的分析数据，IonMonkey 编译器可以生成高度优化的代码。 如果尝试优化失败，IonMonkey 将回退到 Baseline 阶段的代码。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-5-20250731195703-glc434n.svg">​</p>
<p>　　Chakra，用于 Edge 和 <span class="exturl" data-url="aHR0cHM6Ly9naXRodWIuY29tL25vZGVqcy9ub2RlLWNoYWtyYWNvcmU=">Node-ChakraCore<i class="fa fa-external-link-alt"></i></span> 两个项目的微软 JavaScript 引擎，也有类似两个优化编译器的设置。解释器将代码优化成 SimpleJIT——其中 JIT 代表 Just-In-Time 编译器——它可以生成部分优化的代码。 结合分析数据，FullJIT 可以生成更深入优化的代码。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-6-20250731195703-aeps8wd.svg">​</p>
<p>　　JavaScriptCore（缩写为 JSC），Apple 的 JavaScript 引擎，被用于 Safari 和 React Native 两个项目中，它通过三种不同的优化编译器使效果达到极致。低级解释器 LLInt 将代码解释后传递给 Baseline 编译器，而（经过 Baseline 编译器）优化后的代码便传给了 DFG 编译器，（在 DFG 编译器处理后）结果最终传给了 FTL 编译器进行处理。</p>
<p>　　为什么有些引擎会拥有更多的优化编译器呢？这完全是一些折衷的取舍。解释器可以快速生成字节码，但字节码通常不够高效。另一方面，优化编译器处理需要更长的时间，但最终会生成更高效的机器码。到底是快速获取可执行的代码（解释器），还是花费更多时间但最终以最佳性能运行代码（优化编译器），这其中包含一个平衡点。一些引擎选择添加具有不同耗时&#x2F;效率特性的多个优化编译器，以更高的复杂性为代价来对这些折衷点进行更细粒度的控制。</p>
<p>　　我们刚刚强调了每个 JavaScript 引擎中解释器和优化编译器流程中的主要区别。除了这些差异之外，​<strong>所有 JavaScript 引擎都有相同的架构</strong>​：那就是拥有一个解析器和某种解释器&#x2F;编译器流程。</p>
<h2 id="2-JavaScript-对象模型"><a href="#2-JavaScript-对象模型" class="headerlink" title="2. JavaScript 对象模型"></a>2. JavaScript 对象模型</h2><p>　　通过关注一些方面的具体实现，让我们来看看 JavaScript 引擎间还有哪些共同之处。</p>
<p>　　例如，JavaScript 引擎是如何实现 JavaScript 对象模型的，以及他们使用了哪些技巧来加快获取 JavaScript 对象属性的速度？事实证明，所有主要引擎在这一点上的实现都很相似。</p>
<p>　　ECMAScript 规范基本上将所有对象定义为由字符串键值映射到 <em><span class="exturl" data-url="aHR0cHM6Ly90YzM5LmdpdGh1Yi5pby9lY21hMjYyLyNzZWMtcHJvcGVydHktYXR0cmlidXRlcw==">property 属性<i class="fa fa-external-link-alt"></i></span></em> 的字典。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-7-20250731195703-77b6v0c.svg">​</p>
<p>　　除 <code>[[Value]]</code>​ 外，规范还定义了如下属性：</p>
<ul>
<li>​<code>[[Writable]]</code>​ 决定该属性是否可以被重新赋值；</li>
<li>​<code>[[Enumerable]]</code>​ 决定该属性是否出现在 <code>for-in</code>​ 循环中；</li>
<li>​<code>[[Configurable]]</code>​ 决定该属性是否可被删除。</li>
</ul>
<p>　　​<code>[[双方括号]]</code> ​的符号表示看上去有些特别，但这正是规范定义不能直接暴露给 JavaScript 的属性的表示方法。在 JavaScript 中你仍然可以通过 <code>Object.getOwnPropertyDescriptor</code>​ API 获得指定对象的属性值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123; <span class="attr">foo</span>: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="title class_">Object</span>.<span class="title function_">getOwnPropertyDescriptor</span>(object, <span class="string">&#x27;foo&#x27;</span>);</span><br><span class="line"><span class="comment">// → &#123; value: 42, writable: true, enumerable: true, configurable: true &#125;</span></span><br></pre></td></tr></table></figure>

<p>　　JavaScript 就是这个定义对象的，那么数组呢？</p>
<p>　　你可以将数组想象成一组特殊的对象。两者的一个区别便是数组会对数组索引进行特殊的处理。这里所指的数组索引是 ECMAScript 规范中的一个特殊术语。在 JavaScript 中，数组被限制最多只能拥有 2​<sup>32</sup>​-1 项。数组索引是指该限制内的任何有效索引，即从 0 到 2​<sup>32</sup>​-2 的任何整数。</p>
<p>　　另一个区别是数组还有一个充满魔力的 <code>length</code>​ 属性。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>];</span><br><span class="line">array.<span class="property">length</span>; <span class="comment">// → 2</span></span><br><span class="line">array[<span class="number">2</span>] = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">array.<span class="property">length</span>; <span class="comment">// → 3</span></span><br></pre></td></tr></table></figure>

<p>　　在这个例子中，<code>array</code>​ 在生成时长度单位为 2。接着我们向索引为 <code>2</code> ​的位置分配了另一个元素，<code>length</code>​ 属性便自动更新。</p>
<p>　　JavaScript 在定义数组的方式上和对象类似。例如，包括数组索引的所有键值都明确地表示为字符串。 数组中的第一个元素存储在键值为 ‘0’ 的位置下。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-8-20250731195703-qojnacg.svg">​</p>
<p>　　​<code>&#39;length&#39;</code>​ 属性恰好是另一个不可枚举且不可配置的属性。</p>
<p>　　一个元素一旦被添加到数组中，JavaScript 便会自动更新 <code>&#39;length&#39;</code>​ 属性的 <code>[[Value]]</code>​ 属性值。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-9-20250731195703-6bss0jc.svg">​</p>
<p>　　一般来说，数组的行为与对象也非常相似。</p>
<h2 id="3-属性访问的优化"><a href="#3-属性访问的优化" class="headerlink" title="3. 属性访问的优化"></a>3. 属性访问的优化</h2><p>　　让我们深入了解下 JavaScript 引擎是如何有效地应对对象相关操作的。</p>
<p>　　观察 JavaScript 程序，访问属性是最常见的一个操作。使得 JavaScript 引擎能够快速获取属性便至关重要。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;</span><br><span class="line">    <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span>,</span><br><span class="line">    <span class="attr">baz</span>: <span class="string">&#x27;qux&#x27;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Here, we’re accessing the property `foo` on `object`:</span></span><br><span class="line"><span class="title function_">doSomething</span>(object.<span class="property">foo</span>);</span><br><span class="line"><span class="comment">//          ^^^^^^^^^^</span></span><br></pre></td></tr></table></figure>

<h3 id="3-1-Shapes"><a href="#3-1-Shapes" class="headerlink" title="3.1 Shapes"></a>3.1 Shapes</h3><p>　　在 JavaScript 程序中，多个对象具有相同的键值属性是非常常见的。这些对象都具有相同的形状。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="comment">// `object1` and `object2` have the same shape.</span></span><br></pre></td></tr></table></figure>

<p>　　访问具有相同形状对象的相同属性也很常见：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">logX</span>(<span class="params">object</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(object.<span class="property">x</span>);</span><br><span class="line">    <span class="comment">//          ^^^^^^^^</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> object1 = &#123; <span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">3</span>, <span class="attr">y</span>: <span class="number">4</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="title function_">logX</span>(object1);</span><br><span class="line"><span class="title function_">logX</span>(object2);</span><br></pre></td></tr></table></figure>

<p>　　考虑到这一点，JavaScript 引擎可以根据对象的形状来优化对象的属性获取。它是这么实现的。</p>
<p>　　假设我们有一个具有属性 <code>x</code>​ 和 <code>y</code>​ 的对象，它使用我们前面讨论过的字典数据结构：它包含用字符串表示的键值，而它们指向各自的属性值。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-10-20250731195703-9xiyl9c.svg">​</p>
<p>　　如果你访问某个属性，例如 <code>object.y</code>​，JavaScript 引擎会在 <code>JSObject</code>​ 中查找键值 <code>&#39;y&#39;</code>​，然后加载相应的属性值，最后返回 <code>[[Value]]</code>​。</p>
<p>　　但这些属性值在内存中是如何存储的呢？我们是否应该将它们存储为 <code>JSObject</code>​ 的一部分？假设我们稍后会遇到更多同形状的对象，那么在 <code>JSObject</code>​ 自身存储包含属性名和属性值的完整字典便是很浪费（空间）的，因为对具有相同形状的所有对象我们都重复了一遍属性名称。 它太冗余且引入了不必要的内存使用。 作为优化，引擎将对象的 <code>Shape</code>​ 分开存储。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-11-20250731195703-1kibgs1.svg">​</p>
<p>　　​<code>Shape</code>​ 包含除 <code>[[Value]]</code>​ 之外的所有属性名和其余特性。相反，<code>Shape</code>​ 包含 <code>JSObject</code>​ 内部值的偏移量，以便 JavaScript 引擎知道去哪查找具体值。每个具有相同形状的 <code>JSObject</code>​ 都指向这个 <code>Shape</code>​ 实例。 现在每个 <code>JSObject</code>​ 只需要存储对这个对象来说唯一的那些值。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-12-20250731195703-velqwtf.svg">​</p>
<p>　　当我们有多个对象时，优势变得清晰可见。无论有多少个对象，只要它们具有相同的形状，我们只需要将它们的形状与键值属性信息存储一次！</p>
<p>　　所有的 JavaScript 引擎都使用了形状作为优化，但称呼各有不同：</p>
<ul>
<li>学术论文称它们为 ​<em>Hidden Classes</em>​（容易与 JavaScript 中的类概念混淆）</li>
<li>V8 将它们称为 ​<em>Maps</em>​（容易与 JavaScript 中的 <code>Map</code>​ 概念混淆）</li>
<li>Chakra 将它们称为 ​<em>Types</em>​（容易与 JavaScript 中的动态类型和关键字 <code>typeof</code>​ 混淆）</li>
<li>JavaScriptCore 称它们为 <em>Structures</em></li>
<li>SpiderMonkey 称他们为 <em>Shapes</em></li>
</ul>
<p>　　本文中，我们会继续称它为 ​<em>shapes</em>​。</p>
<h2 id="3-2-Transition-链与树"><a href="#3-2-Transition-链与树" class="headerlink" title="3.2 Transition 链与树"></a>3.2 Transition 链与树</h2><p>　　如果你有一个具有特定形状的对象，但你又向它添加了一个属性，此时会发生什么？ JavaScript 引擎是如何找到这个新形状的？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object = &#123;&#125;;</span><br><span class="line">object.<span class="property">x</span> = <span class="number">5</span>;</span><br><span class="line">object.<span class="property">y</span> = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>　　在 JavaScript 引擎中，shapes 的表现形式被称作 ​<em>transition 链</em>​。以下展示一个示例：</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-13-20250731195703-2r9o102.svg">​</p>
<p>　　该对象在初始化时没有任何属性，因此它指向一个空的 shape。下一个语句为该对象添加值为 <code>5</code>​ 的属性 <code>“x”</code>​，所以 JavaScript 引擎转向一个包含属性 <code>“x”</code>​ 的 Shape，并向 <code>JSObject</code>​ 的第一个偏移量为 0 处添加了一个值 <code>5</code>​。 接下来一个语句添加了一个属性 <code>&#39;y&#39;</code>​，引擎便转向另一个包含 <code>&#39;x&#39;</code>​ 和 <code>&#39;y&#39;</code>​ 的 Shape，并将值 <code>6</code>​ 附加到 <code>JSObject</code>​（位于偏移量 <code>1</code>​ 处）。</p>
<p>　　我们甚至不需要为每个 Shape 存储完整的属性表。相反，每个 Shape 只需要知道它引入的新属性。 例如在此例中，我们不必在最后一个 Shape 中存储关于 <code>&#39;x&#39;</code>​ 的信息，因为它可以在更早的链上被找到。要做到这一点，每一个 Shape 都会与其之前的 Shape 相连：</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-14-20250731195703-73xvy14.svg">​</p>
<p>　　如果你在 JavaScript 代码中写到了 <code>o.x</code>​，则 JavaScript 引擎会沿着 transition 链去查找属性 <code>“x”</code>​，直到找到引入属性 <code>“x”</code> ​的 Shape。</p>
<p>　　但是，如果不能只创建一个 transition 链呢？例如，如果你有两个空对象，并且你为每个对象都添加了一个不同的属性？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.<span class="property">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123;&#125;;</span><br><span class="line">object2.<span class="property">y</span> = <span class="number">6</span>;</span><br></pre></td></tr></table></figure>

<p>　　在这种情况下我们便必须进行分支操作，此时我们最终会得到一个 <em>transition 树</em> 而不是 transition 链：</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-15-20250731195703-c89n4qh.svg">​</p>
<p>　　在这里，我们创建一个空对象 <code>a</code>​，然后为它添加一个属性 <code>&#39;x&#39;</code>​。 我们最终得到一个包含单个值的 <code>JSObject</code>​，以及两个 Shapes：空 Shape 和仅包含属性 <code>x</code> ​的 Shape。</p>
<p>　　第二个例子也是从一个空对象 <code>b</code>​ 开始的，但之后被添加了一个不同的属性 <code>&#39;y&#39;</code>​。我们最终形成两个 shape 链，总共是三个 shape。</p>
<p>　　这是否意味着我们总是需要从空 shape 开始呢？ 并不是。引擎对已包含属性的对象字面量会应用一些优化。比方说，我们要么从空对象字面量开始添加 <code>x</code>​ 属性，要么有一个已经包含属性 <code>x</code>​ 的对象字面量：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> object1 = &#123;&#125;;</span><br><span class="line">object1.<span class="property">x</span> = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">const</span> object2 = &#123; <span class="attr">x</span>: <span class="number">6</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>　　在第一个例子中，我们从空 shape 开始，然后转向包含 <code>x</code>​ 的 shape，这正如我们我们之前所见。</p>
<p>　　在 <code>object2</code>​ 一例中，直接生成具有属性 <code>x</code>​ 的对象是有意义的，而不是从空对象开始然后进行 transition 连接。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-16-20250731195703-xacgv8w.svg">​</p>
<p>　　包含属性 <code>&#39;x&#39;</code>​ 的对象字面量从包含 <code>&#39;x&#39;</code>​ 的 shape 开始，可以有效地跳过空的 shape。V8 和 SpiderMonkey （至少）正是这么做的。这种优化缩短了 transition 链，并使得从字面量构造对象更加高效。</p>
<p>　　Benedikt 的博文 <span class="exturl" data-url="aHR0cHM6Ly9tZWRpdW0uY29tL0BibWV1cmVyL3N1cnByaXNpbmctcG9seW1vcnBoaXNtLWluLXJlYWN0LWFwcGxpY2F0aW9ucy02MzAxNWI1MGFiYw==">surprising polymorphism in React applications<i class="fa fa-external-link-alt"></i></span> 讨论了这些微妙之处是如何影响实际性能的。</p>
<h3 id="3-3-Inline-Caches-ICs"><a href="#3-3-Inline-Caches-ICs" class="headerlink" title="3.3 Inline Caches (ICs)"></a>3.3 Inline Caches (ICs)</h3><p>　　Shapes 背后的主要动机是 Inline Caches 或 ICs 的概念。ICs 是促使 JavaScript 快速运行的关键因素！JavaScript 引擎利用 ICs 来记忆去哪里寻找对象属性的信息，以减少昂贵的查找次数。</p>
<p>　　这里有一个函数 <code>getX</code>​，它接受一个对象并从中取出属性 <code>x</code>​ 的值：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">getX</span>(<span class="params">o</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> o.<span class="property">x</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>　　如果我们在 JSC 中执行这个函数，它会生成如下字节码：</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-17-20250731195703-j1tl617.svg">​</p>
<p>　　指令一 <code>get_by_id</code>​ 从第一个参数（<code>arg1</code>​）中加载属性 <code>&#39;x&#39;</code>​ 值并将其存储到地址 <code>loc0</code>​ 中。 第二条指令返回我们存储到 <code>loc0</code>​ 中的内容。</p>
<p>　　JSC 还在 <code>get_by_id</code>​ 指令中嵌入了 Inline Cache，它由两个未初始化的插槽组成。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-18-20250731195703-4wsoybd.svg">​</p>
<p>　　现在让我们假设我们用对象 <code>{x：&#39;a&#39;}</code>​ 调用 <code>getX</code>​ 函数。正如我们所知，这个对象有一个包含属性 <code>&#39;x&#39;</code>​ 的 Shape，该 Shape 存储了属性 <code>x</code>​ 的偏移量和其他特性。当你第一次执行该函数时，<code>get_by_id</code>​ 指令将查找属性 <code>&#39;x&#39;</code>​，然后发现其值存储在偏移量 <code>0</code>​ 处。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-19-20250731195703-4rre9gv.svg">​</p>
<p>　　嵌入到 <code>get_by_id</code>​ 指令中的 IC 存储该属性的 shape 和偏移量：</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-20-20250731195703-wspc1xs.svg">​</p>
<p>　　对于后续运行，IC 只需要对比 shape，如果它与以前相同，只需从记忆的偏移量处加载该属性值。具体来说，如果 JavaScript 引擎看到一个对象的 shape 之前被 IC 记录过，它则不再需要接触属性信息——而是完全可以跳过昂贵的属性信息查找（过程）。这比每次查找属性要快得多。</p>
<h2 id="4-高效存储数组"><a href="#4-高效存储数组" class="headerlink" title="4. 高效存储数组"></a>4. 高效存储数组</h2><p>　　对于数组来说，存储属性诸如<em>数组索引</em>等是非常常见的。这些属性的值被称为数组元素。存储每个数组中的每个数组元素的属性特性（property attributes）将是一种很浪费的存储方式。相反，由于数组索引默认属性是可写的、可枚举的并且可以配置的，JavaScript 引擎利用这一点，将数组元素与其他命名属性分开存储。</p>
<p>　　考虑这个数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> array = [</span><br><span class="line">    <span class="string">&#x27;#jsconfeu&#x27;</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>

<p>　　引擎存储了数组长度（<code>1</code>​），并指向包含 <code>offset</code>​ 和 <code>&#39;length&#39;</code>​ 特性属性的 Shape。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-21-20250731195703-a7oh50b.svg">​</p>
<p>　　这与我们之前见过的类似……但数组值存储在哪里呢？</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-22-20250731195703-q246gty.svg">​</p>
<p>　　每个数组都有一个单独的 ​<em>elements backing store</em>​，其中包含所有数组索引的属性值。JavaScript 引擎不必为数组元素存储任何属性特性，因为它们通常都是可写的，可枚举的以及可配置的。</p>
<p>　　那么如果不是通常的情况呢？如果更改了数组元素的属性，该怎么办？</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Please don’t ever do this!</span></span><br><span class="line"><span class="keyword">const</span> array = <span class="title class_">Object</span>.<span class="title function_">defineProperty</span>(</span><br><span class="line">    [],</span><br><span class="line">    <span class="string">&#x27;0&#x27;</span>,</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="attr">value</span>: <span class="string">&#x27;Oh noes!!1&#x27;</span>,</span><br><span class="line">        <span class="attr">writable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">enumerable</span>: <span class="literal">false</span>,</span><br><span class="line">        <span class="attr">configurable</span>: <span class="literal">false</span>,</span><br><span class="line">    &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>

<p>　　上面的代码片段定义了一个名为 <code>&#39;0&#39;</code>​ 的属性（这恰好是一个数组索引），但其特性（<code>value</code>​）被设置为了一个非默认值。</p>
<p>　　在这种边缘情况下，JavaScript 引擎会将全部的 elements backing store 表示为一个由数组下标映射到属性特性的字典。</p>
<p><img data-src="/blog/./images/assets/2018-06-17-Shapes-ICs-23-20250731195703-3uvsw23.svg">​</p>
<p>　　即使只有一个数组元素具有非默认属性，整个数组的 backing store 处理也会进入这种缓慢而低效的模式。</p>
<p>　　避免在数组索引上使用 <code>Object.defineProperty</code>​！</p>
<p>　　 （我不知道为什么你会想这样做。这看上去似乎是一个奇怪的且毫无价值的事情。）</p>
<h2 id="5-Take-aways"><a href="#5-Take-aways" class="headerlink" title="5. Take-aways"></a>5. Take-aways</h2><p>　　我们已经学习了 JavaScript 引擎是如何存储对象和数组的，以及 Shapes 和 IC 是如何优化针对它们的常见操作的。基于这些知识，我们确定了一些有助于提升性能的实用 JavaScript 编码技巧：</p>
<ul>
<li>始终以相同的方式初始化对象，以确保它们不会走向不同的 shape 方向。</li>
<li>不要混淆数组元素的属性特性（property attributes），以确保可以高效地存储和操作它们。</li>
</ul>
<p>　　（完）</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/blog/tags/js/" rel="tag"><i class="fa fa-tag"></i> js</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/blog/%E4%BB%8E%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F%E4%BC%98%E5%8C%96%E6%80%A7%E8%83%BD/" rel="prev" title="从代码实现方式优化性能">
                  <i class="fa fa-angle-left"></i> 从代码实现方式优化性能
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/blog/01%20%E4%BB%80%E4%B9%88%E6%98%AF%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%EF%BC%9F/" rel="next" title="01 什么是神经网络？">
                  01 什么是神经网络？ <i class="fa fa-angle-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






    <div class="comments utterances-container"></div>
</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">Rion</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
      <span>站点总字数：</span>
    <span title="站点总字数">101k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
      <span>站点阅读时长 &asymp;</span>
    <span title="站点阅读时长">6:09</span>
  </span>
</div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>
<script class="next-config" data-name="utterances" type="application/json">{"enable":true,"repo":"afetmin/blog","issue_term":"pathname","theme":"github-light"}</script>
<script src="/blog/js/third-party/comments/utterances.js" defer></script>

</body>
</html>
