<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>一些Vue小技巧</title>
    <url>/blog/%E4%B8%80%E4%BA%9B%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h2 id="关于-vue-filters"><a href="#关于-vue-filters" class="headerlink" title="关于 vue.filters"></a>关于 vue.filters</h2><p>可以写在单个组件内，也可以单独写全局的然后加到 main.js 中，像是日期格式，数字格式就可以写在全局</p>
<h2 id="和！！"><a href="#和！！" class="headerlink" title="~~和！！"></a>~~和！！</h2><p>&#126;是按位取反运算，&#126;&#126;是取反两次。<br>&#126;&#126;的作用是去掉小数部分，因为位运算的操作值要求是整数，其结果也是整数，所以经过位运算的都会自动变成整数。<br>！一个！是取反，！！两个再取反，就是强制转换成 Boolen 类型</p>
<h2 id="关于-markdown-语法"><a href="#关于-markdown-语法" class="headerlink" title="关于 markdown 语法"></a>关于 markdown 语法</h2><p>如果要使用 Markdown 保留字，可以使用 Unicode 字符。如上面的&#126;&#126;,两边加&#126;&#126;会导致形成文字之间产生删除线，把&#126;&#126;换成<code>&amp;#126;&amp;#126;</code>就可以了。<a href="http://tool.oschina.net/encode">Unicode 在线转义</a></p>
<h2 id="js-和-css-两用样式"><a href="#js-和-css-两用样式" class="headerlink" title="js 和 css 两用样式"></a>js 和 css 两用样式</h2><p>template 中需要动态定义样式，通常做法：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; color: textColor &#125;&quot;</span>&gt;</span>Text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="title function_">data</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">return</span> &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="attr">textColor</span>: <span class="string">&quot;#ff5000&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>高端做法：</p>
<ul>
<li>定义 scss 文件</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><span class="line"><span class="variable">$menuActiveText</span>: <span class="number">#409eff</span>;</span><br><span class="line"></span><br><span class="line">:export &#123;</span><br><span class="line">  menuActiveText: <span class="variable">$menuActiveText</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>在 js 中引用：<ul>
<li>使用 import 引用 scss 文件</li>
<li>定义 computed 将 styles 对象变成响应式对象</li>
<li>在 template 中使用 styles 对象</li>
</ul>
</li>
</ul>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">:style</span>=<span class="string">&quot;&#123; color: styles.menuActiveText &#125;&quot;</span>&gt;</span>Text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">import</span> styles <span class="keyword">from</span> <span class="string">&quot;@/styles/variables.scss&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">export</span> <span class="keyword">default</span> &#123;</span></span><br><span class="line"><span class="language-javascript">    <span class="attr">computed</span>: &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="title function_">styles</span>(<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="keyword">return</span> styles</span></span><br><span class="line"><span class="language-javascript">      &#125;,</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">  &#125;</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h2 id="连续解构"><a href="#连续解构" class="headerlink" title="连续解构"></a>连续解构</h2><p>从数组第一个对象元素中提取某个属性，比如：err 对象中包含一个 errors 数组，errors 数组每一个对象都包含一个 msg 属性</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">err = &#123;</span><br><span class="line">  <span class="attr">errors</span>: [</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="attr">msg</span>: <span class="string">&quot;this is a message&quot;</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">  ],</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>快速的提取方法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> [&#123; msg &#125;] = err.<span class="property">errors</span></span><br></pre></td></tr></table></figure>

<p>如果不用解构写法为：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> msg = err.<span class="property">errors</span>[<span class="number">0</span>].<span class="property">msg</span></span><br></pre></td></tr></table></figure>

<p>真不错！</p>
<h2 id="vm-nextTick"><a href="#vm-nextTick" class="headerlink" title="vm.$nextTick"></a>vm.$nextTick</h2><p>vue 更新 DOM 是异步的，如果你想基于更新后的 DOM 状态来做点什么，为了在数据变化之后等待 Vue 完成更新 DOM，可以在数据变化之后立即使用 Vue.nextTick(callback)。这样回调函数将在 DOM 更新完成后被调用。详情参见:<a href="https://cn.vuejs.org/v2/guide/reactivity.html#%E5%BC%82%E6%AD%A5%E6%9B%B4%E6%96%B0%E9%98%9F%E5%88%97">异步更新队列</a></p>
<h2 id="columns-分页"><a href="#columns-分页" class="headerlink" title="columns 分页"></a>columns 分页</h2><p>利用 columns 实现小说分页效果，每一列的高度与父元素相同</p>
<h2 id="绝对定位居中"><a href="#绝对定位居中" class="headerlink" title="绝对定位居中"></a>绝对定位居中</h2><figure class="highlight css"><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.demo</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="使页面的左右边距相同"><a href="#使页面的左右边距相同" class="headerlink" title="使页面的左右边距相同"></a>使页面的左右边距相同</h2><p>可以父元素加 padding：15px, 子元素加 margin：15px， 这样所有间隙都是 30px。</p>
<h2 id="math-floor-和-0"><a href="#math-floor-和-0" class="headerlink" title="math.floor 和 | 0"></a>math.floor 和 <code>| 0</code></h2><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">;(<span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="number">10</span> / <span class="number">3</span>) === <span class="number">10</span> / <span class="number">3</span>) | <span class="number">0</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>三次握手和四次挥手</title>
    <url>/blog/%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/</url>
    <content><![CDATA[<h2 id="三次握手"><a href="#三次握手" class="headerlink" title="三次握手"></a>三次握手</h2><p>• 第一次握手([SYN], Seq &#x3D; x)<br>客户端发送一个SYN标记的包，Seq初始序列号x，发送完成后客户端进入SYN_SEND状态。<br>• 第二次握手([SYN,ACK], Seq &#x3D; y, ACK &#x3D; x + 1)<br>服务器返回确认包(ACK)应答，同时还要发送一个SYN包回去。ACK &#x3D; x + 1,表示确认收到(客户端发来的Seq值 + 1)，Seq &#x3D; y, 表示让客户端确认是否能收到。发送完成后服务端进入SYN_RCVD状态。<br>• 第三次握手([ACK], ACK &#x3D; y + 1)<br>客户端再次发送确认包(ACK),ACK &#x3D; y + 1, 表示确认收到服务器的包（服务端发来的Seq值 + 1）。客户端发送完毕后，进入ESTABLISHED状态，服务端接收到这个包，也进入ESTABLISHED状态, TCP握手结束。</p>
<h2 id="四次挥手"><a href="#四次挥手" class="headerlink" title="四次挥手"></a>四次挥手</h2><p>• 第一次挥手（[FIN], Seq &#x3D; x）<br>客户端发送一个FIN标记的包，告诉服务器需要关闭连接，表示自己不用发送数据了，但是还可以接收数据。发送完成后，客户端进入FIN_WAIT_1状态。<br>• 第二次挥手 ([ACK], ACK &#x3D; x + 1)<br>服务端发送一个ACK的确认包，告诉客户端接收到关闭的请求，但是还没有准备好。发送完成后，服务端进入CLOSE_WAIT状态，客户端收到这个包后，进入FIN_WAIT_2，等待服务器关闭连接。<br>• 第三次挥手 ([FIN], Seq &#x3D; y)<br>服务端准备好关闭连接时，发送FIN标记的包，告诉客户端准备关闭了。发送完成后，服务端进入LAST_ACK状态，等待客户端确认。<br>• 第四次挥手 ([ACK], ACK &#x3D; y + 1)<br>客户端接收到服务端的关闭请求，再发送ACK标记的确认包，进入TIME_WAIT状态，等待服务端可能请求重传的ACK包。<br>服务端接收到ACK包后，关闭连接，进入CLOSED状态。<br>客户端在等待固定时间(两个最大段生命周期)后，没有接收到服务的ACK包，认为服务器已关闭连接，自己也关闭连接，进入CLOSED状态。<br>###　为什么三次握手<br>“3次握手”的作用就是双方都能明确自己和对方的收、发能力是正常的。<br>第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的。<br>第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。 从客户端的视角来看，我接到了服务端发送过来的响应数据包，说明服务端接收到了我在第一次握手时发送的网络包，并且成功发送了响应数据包，这就说明，服务端的接收、发送能力正常。而另一方面，我收到了服务端的响应数据包，说明我第一次发送的网络包成功到达服务端，这样，我自己的发送和接收能力也是正常的。<br>第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力，服务端的发送、接收能力是正常的。 第一、二次握手后，服务端并不知道客户端的接收能力以及自己的发送能力是否正常。而在第三次握手时，服务端收到了客户端对第二次握手作的回应。从服务端的角度，我在第二次握手时的响应数据发送出去了，客户端接收到了。所以，我的发送能力是正常的。而客户端的接收能力也是正常的。</p>
<h3 id="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"><a href="#为什么建立连接是三次握手，而关闭连接却是四次挥手呢？" class="headerlink" title="为什么建立连接是三次握手，而关闭连接却是四次挥手呢？"></a>为什么建立连接是三次握手，而关闭连接却是四次挥手呢？</h3><p>这是因为服务端在LISTEN状态下，收到建立连接请求的SYN报文后，把ACK和SYN放在一个报文里发送给客户端。而关闭连接时，当收到对方的FIN报文时，仅仅表示对方不再发送数据了但是还能接收数据，己方是否现在关闭发送数据通道，需要上层应用来决定，因此，己方ACK和FIN一般都会分开发送。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
  </entry>
  <entry>
    <title>createObjectURL</title>
    <url>/blog/%E5%85%B3%E4%BA%8EcreateObjectURL/</url>
    <content><![CDATA[<h2 id="createObjectURL-是什么"><a href="#createObjectURL-是什么" class="headerlink" title="createObjectURL 是什么"></a>createObjectURL 是什么</h2><blockquote>
<p>URL.createObjectURL() 静态方法会创建一个 DOMString，其中包含一个表示参数中给出的对象的 URL。这个 URL 的生命周期和创建它的窗口中的 document 绑定。这个新的 URL 对象表示指定的 File 对象或 Blob 对象。 — MDN</p>
</blockquote>
<span id="more"></span>

<h2 id="Blob-URL-Object-URL"><a href="#Blob-URL-Object-URL" class="headerlink" title="Blob URL&#x2F;Object URL"></a>Blob URL&#x2F;Object URL</h2><p>Blob URL&#x2F;Object URL 是⼀种伪协议，允许 Blob 和 File 对象⽤作图像，下载⼆进制数据链接等的 URL<br>源。在浏览器中，我们使⽤ URL.createObjectURL ⽅法来创建 Blob URL，该⽅法接收⼀个 Blob 对<br>象，并为其创建⼀个唯⼀的 URL，其形式为 <code>blob:&lt;origin&gt;/&lt;uuid&gt;</code> ，对应的示例如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="attr">blob</span>:<span class="attr">https</span>:<span class="comment">//example.org/40a5fb5a-d56d-4a33-b4e2-0acf6a8e5f641</span></span><br></pre></td></tr></table></figure>

<p>浏览器内部为每个通过 URL.createObjectURL ⽣成的 URL 存储了⼀个 URL → Blob 映射。因此，此<br>类 URL 较短，但可以访问 Blob 。⽣成的 URL 仅在当前⽂档打开的状态下才有效。它允许引⽤<br><code>&lt;img&gt; 、 &lt;a&gt;</code> 中的 Blob ，但如果你访问的 Blob URL 不再存在，则会从浏览器中收到 404 错误。</p>
<p>上述的 Blob URL 看似很不错，但实际上它也有副作⽤。虽然存储了 URL → Blob 的映射，但 Blob 本<br>身仍驻留在内存中，浏览器⽆法释放它。映射在⽂档卸载时⾃动清除，因此 Blob 对象随后被释放。但<br>是，如果应⽤程序寿命很⻓，那不会很快发⽣。因此，如果我们创建⼀个 Blob URL，即使不再需要该<br>Blob，它也会存在内存中。</p>
<p>针对这个问题，我们可以调⽤ URL.revokeObjectURL(url) ⽅法，从内部映射中删除引⽤，从⽽允许<br>删除 Blob（如果没有其他引⽤），并释放内存。</p>
<h2 id="createObjectURL-可以用来做什么"><a href="#createObjectURL-可以用来做什么" class="headerlink" title="createObjectURL 可以用来做什么"></a>createObjectURL 可以用来做什么</h2><p>比如显示上传的预览图</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">input</span></span></span><br><span class="line"><span class="tag">    <span class="attr">type</span>=<span class="string">&quot;file&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">multiple</span></span></span><br><span class="line"><span class="tag">    <span class="attr">id</span>=<span class="string">&quot;fileInput&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">onchange</span>=<span class="string">&quot;previewFiles(this.files)&quot;</span></span></span><br><span class="line"><span class="tag">  /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">ul</span> <span class="attr">id</span>=<span class="string">&quot;preview&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">    <span class="keyword">const</span> inputEl = <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;fileInput&#x27;</span>) <span class="keyword">const</span> ulEle =</span></span><br><span class="line"><span class="language-javascript">    <span class="variable language_">document</span>.<span class="title function_">getElementById</span>(<span class="string">&#x27;preview&#x27;</span>) <span class="keyword">function</span> <span class="title function_">previewFiles</span>(<span class="params">files</span>)&#123;<span class="string">&quot; &quot;</span>&#125;</span></span><br><span class="line"><span class="language-javascript">    &#123;<span class="title class_">Array</span>.<span class="title function_">from</span>(files).<span class="title function_">forEach</span>(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      ulEle.<span class="title function_">appendChild</span>(li)</span></span><br><span class="line"><span class="language-javascript">      <span class="keyword">const</span> img = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;img&quot;</span>)</span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">src</span> = <span class="variable constant_">URL</span>.<span class="title function_">createObjectURL</span>(file)</span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">height</span> = <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">width</span> = <span class="number">100</span></span></span><br><span class="line"><span class="language-javascript">      img.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span></span><br><span class="line"><span class="language-javascript">        <span class="comment">// 当图片加载完成之后对象URL就不再需要了</span></span></span><br><span class="line"><span class="language-javascript">        <span class="variable constant_">URL</span>.<span class="title function_">revokeObjectURL</span>(<span class="variable language_">this</span>.<span class="property">src</span>)</span></span><br><span class="line"><span class="language-javascript">      &#125;</span></span><br><span class="line"><span class="language-javascript">      li.<span class="title function_">appendChild</span>(img)</span></span><br><span class="line"><span class="language-javascript">    &#125;)&#125;</span></span><br><span class="line"><span class="language-javascript">  </span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>来看看效果：</p>
<p><img data-src="/blog/./%E5%85%B3%E4%BA%8EcreateObjectURL/1.png" alt="效果"></p>
<blockquote>
<p>在每次调用  <code>createObjectURL()</code>  方法时，都会创建一个新的 URL 对象，即使你已经用相同的对象作为参数创建过。当不再需要这些 URL 对象时，每个对象必须通过调用  <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/URL/revokeObjectURL">URL.revokeObjectURL()</a> 方法来释放。</p>
</blockquote>
<p>浏览器在 document 卸载的时候，会自动释放它们，但是为了获得最佳性能和内存使用状况，你应该在安全的时机主动释放掉它们。</p>
<h2 id="FileReader-的-readAsDataURL"><a href="#FileReader-的-readAsDataURL" class="headerlink" title="FileReader 的 readAsDataURL"></a>FileReader 的 readAsDataURL</h2><blockquote>
<p>readAsDataURL 方法会读取指定的 Blob 或 File 对象。读取操作完成的时候，readyState 会变成已完成 DONE，并触发 loadend 事件，同时 result 属性将包含一个 data:URL 格式的字符串（base64 编码）以表示所读取文件的内容。</p>
</blockquote>
<p>还是上一个例子</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">useFileReaderPreivewFiles</span>(<span class="params">files</span>) &#123;</span><br><span class="line">  <span class="title class_">Array</span>.<span class="title function_">from</span>(files).<span class="title function_">forEach</span>(<span class="function">(<span class="params">file</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> reader = <span class="keyword">new</span> <span class="title class_">FileReader</span>()</span><br><span class="line">    <span class="keyword">const</span> li = <span class="variable language_">document</span>.<span class="title function_">createElement</span>(<span class="string">&quot;li&quot;</span>)</span><br><span class="line">    ulEle.<span class="title function_">appendChild</span>(li)</span><br><span class="line">    reader.<span class="property">onload</span> = <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">      <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">      img.<span class="property">height</span> = <span class="number">100</span></span><br><span class="line">      img.<span class="property">width</span> = <span class="number">100</span></span><br><span class="line">      img.<span class="property">src</span> = e.<span class="property">target</span>.<span class="property">result</span></span><br><span class="line">      li.<span class="title function_">appendChild</span>(img)</span><br><span class="line">    &#125;</span><br><span class="line">    reader.<span class="title function_">readAsDataURL</span>(file)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>同样的效果:</p>
<p><img data-src="/blog/./%E5%85%B3%E4%BA%8EcreateObjectURL/2.png" alt="效果图"></p>
<p>来一张终极图：</p>
<p><img data-src="/blog/./%E5%85%B3%E4%BA%8EcreateObjectURL/3.jpg" alt="data_url.jpg"></p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>关于vue的mixin</title>
    <url>/blog/%E5%85%B3%E4%BA%8Evue%E7%9A%84mixin/</url>
    <content><![CDATA[<h2 id="vue的mixin"><a href="#vue的mixin" class="headerlink" title="vue的mixin"></a>vue的mixin</h2><p>当有多个组件写了多个同样的语句时，可以使用vue的mixin机制<br>创建一个utils&#x2F;mixin.js文件，内容如下：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;</span><br><span class="line">  mapGetters,</span><br><span class="line">  mapActions</span><br><span class="line">&#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> bookMixin = &#123;</span><br><span class="line">  <span class="attr">computed</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapGetters</span>([<span class="string">&#x27;bookName&#x27;</span>, <span class="string">&#x27;bookCover&#x27;</span>]),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">methods</span>: &#123;</span><br><span class="line">    ...<span class="title function_">mapActions</span>([<span class="string">&#x27;setBookName&#x27;</span>, <span class="string">&#x27;setBookCover&#x27;</span>])</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<span id="more"></span>
<p>接下来就可以在组件内这样写：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; bookMixin &#125; <span class="keyword">from</span> <span class="string">&#x27;utils/mixin&#x27;</span></span><br><span class="line">  <span class="attr">mixins</span>:[bookMixin]</span><br><span class="line">  <span class="attr">methods</span>: &#123;&#125;</span><br></pre></td></tr></table></figure>
<p>这样可以将vuex的内容在一处增加，多处复用。</p>
<p>mapActions是写到methods里的，这样就可以替换这种写法</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 原来写法</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="property">$store</span>.<span class="title function_">dispatch</span>(<span class="string">&#x27;setBookName&#x27;</span>,<span class="variable language_">this</span>.<span class="property">bookName</span>)</span><br><span class="line"><span class="comment">// 优雅写法</span></span><br><span class="line"><span class="variable language_">this</span>.<span class="title function_">setBookName</span>(<span class="variable language_">this</span>.<span class="property">bookName</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>vue</category>
      </categories>
  </entry>
  <entry>
    <title>关于中间件</title>
    <url>/blog/%E5%85%B3%E4%BA%8E%E4%B8%AD%E9%97%B4%E4%BB%B6/</url>
    <content><![CDATA[<h1 id="中间件"><a href="#中间件" class="headerlink" title="中间件"></a>中间件</h1><p>使用 node 构建 web 应用时，并不单单响应一个简单的 hello world，在一个实际的业务中，我们也许会做这些：</p>
<ul>
<li>请求方法的判断。</li>
<li>URL 的路径解析。</li>
<li>URL 中查询字符串解析。</li>
<li>Cookie 的解析。</li>
<li>Basic 认证。</li>
<li>表单数据的解析。</li>
<li>任意格式文件的上传处理。</li>
</ul>
<span id="more"></span>
<p>这样一个完整的项目中需要处理很多的细节，当然你也可以都写在一起，但这样代码的耦合程度太高了，而且以后维护起来也令人头大。</p>
<p>为此引入<strong>中间件（middleware）</strong>来简化和隔离这些基础设施与业务逻辑之间的细节，让开发者能够关注在业务的开发上，以达到提升开发效率的目的。</p>
<p>理解中间件的最简单的方式是实现一个基础的中间件模式，一个中间件其实就是一个函数。</p>
<p>一个简单的中间件模式需要一个 use 方法来进行中间件的注册，需要一个 run 来执行这些注册的中间件</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> app = &#123;</span><br><span class="line">  <span class="attr">fns</span>: [],</span><br><span class="line">  <span class="title function_">callback</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(ctx)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">use</span>(<span class="params">fn</span>) &#123;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fns</span>.<span class="title function_">push</span>(fn)</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="title function_">run</span>(<span class="params">ctx</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="number">0</span></span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">      index++</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">fns</span>.<span class="title function_">forEach</span>(<span class="function">(<span class="params">fn, idx</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (index === idx) <span class="title function_">fn</span>(ctx, next)</span><br><span class="line">    &#125;)</span><br><span class="line">    index === <span class="variable language_">this</span>.<span class="property">fns</span>.<span class="property">length</span> &amp;&amp; <span class="variable language_">this</span>.<span class="title function_">callback</span>(ctx)</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用一下：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">name</span> = <span class="string">&quot;ranxiu&quot;</span></span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">use</span>(<span class="function">(<span class="params">ctx, next</span>) =&gt;</span> &#123;</span><br><span class="line">  ctx.<span class="property">gender</span> = <span class="string">&quot;girl&quot;</span></span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.<span class="title function_">run</span>(&#123;&#125;)</span><br><span class="line"><span class="comment">// 打印：&#123;name:&quot;ranxiu&quot;,gender:&quot;girl&quot;&#125;</span></span><br></pre></td></tr></table></figure>

<p>关于 run 函数还有更加优雅的写法：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">run</span>(<span class="params">ctx, stack</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="title function_">next</span> = (<span class="params"></span>) =&gt; &#123;</span><br><span class="line">    <span class="keyword">const</span> middleware = stack.<span class="title function_">shift</span>()</span><br><span class="line">    <span class="keyword">if</span> (middleware) &#123;</span><br><span class="line">      <span class="title function_">middleware</span>(ctx, next) <span class="comment">// 递归调用</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="title function_">next</span>()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再来看看 koa-compose 的中间件：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">compose</span>(<span class="params">middleware</span>) &#123;</span><br><span class="line">  <span class="comment">// 提前判断中间件类型,防止后续错误</span></span><br><span class="line">  <span class="keyword">if</span> (!<span class="title class_">Array</span>.<span class="title function_">isArray</span>(middleware))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Middleware stack must be an array!&quot;</span>)</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> fn <span class="keyword">of</span> middleware) &#123;</span><br><span class="line">    <span class="comment">// 中间件必须为函数类型</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> fn !== <span class="string">&quot;function&quot;</span>)</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="title class_">TypeError</span>(<span class="string">&quot;Middleware must be composed of functions!&quot;</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">function</span> (<span class="params">context, next</span>) &#123;</span><br><span class="line">    <span class="comment">// 采用闭包将索引缓存,来实现调用计数</span></span><br><span class="line">    <span class="keyword">let</span> index = -<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">dispatch</span>(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">dispatch</span>(<span class="params">i</span>) &#123;</span><br><span class="line">      <span class="comment">// 防止next()方法重复调用</span></span><br><span class="line">      <span class="keyword">if</span> (i &lt;= index)</span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(<span class="keyword">new</span> <span class="title class_">Error</span>(<span class="string">&quot;next() called multiple times&quot;</span>))</span><br><span class="line">      index = i</span><br><span class="line">      <span class="keyword">let</span> fn = middleware[i]</span><br><span class="line">      <span class="keyword">if</span> (i === middleware.<span class="property">length</span>) fn = next</span><br><span class="line">      <span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>()</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// 包装next()返回值为Promise对象</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>(<span class="title function_">fn</span>(context, dispatch.<span class="title function_">bind</span>(<span class="literal">null</span>, i + <span class="number">1</span>)))</span><br><span class="line">      &#125; <span class="keyword">catch</span> (err) &#123;</span><br><span class="line">        <span class="comment">// 异常处理</span></span><br><span class="line">        <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">reject</span>(err)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>两个字：优雅。有时不得不感慨人和人的差距有时比人和狗的差距还大。</p>
<p>拿这个 🌰 来说：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">wait</span>(<span class="params">ms</span>) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> <span class="built_in">setTimeout</span>(resolve, ms || <span class="number">1</span>))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> arr = []</span><br><span class="line"><span class="keyword">const</span> stack = []</span><br><span class="line"></span><br><span class="line"><span class="comment">// type Middleware&lt;T&gt; = (context: T, next: Koa.Next) =&gt; any;</span></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="keyword">async</span> (context, next) =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">6</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="keyword">async</span> (context, next) =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">2</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">5</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">stack.<span class="title function_">push</span>(<span class="keyword">async</span> (context, next) =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="keyword">await</span> <span class="title function_">compose</span>(stack)(&#123;&#125;)</span><br><span class="line"><span class="comment">// arr = [1,2,3,4,5,6]</span></span><br></pre></td></tr></table></figure>

<p>当 i 为 3 时，</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = middleware[i] <span class="comment">//fn=undefined</span></span><br><span class="line"><span class="keyword">if</span> (i === middleware.<span class="property">length</span>) fn = next</span><br><span class="line"><span class="keyword">if</span> (!fn) <span class="keyword">return</span> <span class="title class_">Promise</span>.<span class="title function_">resolve</span>() <span class="comment">//!fn为true</span></span><br></pre></td></tr></table></figure>

<p>直接返回 resolve，之后就执行 next()后面的函数</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">stack.<span class="title function_">push</span>(<span class="keyword">async</span> (context, next) =&gt; &#123;</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">3</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">next</span>()</span><br><span class="line">  <span class="keyword">await</span> <span class="title function_">wait</span>(<span class="number">1</span>)</span><br><span class="line">  arr.<span class="title function_">push</span>(<span class="number">4</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>执行完后返回第二个 next() 后面继续往下执行，知道所有的中间件执行完毕。</p>
<p>这便是众人皆知的“洋葱模型”。你也可以选择只添加前置的处理，就是 await next()前面的操作</p>
<p>，或者后面的处理。</p>
<p>每个中间件足够的小而美，职责单一，同时多个中间件又具备良好的逻辑拓展性和可组合性，并且易于测试。这个设计模式真是太“漂亮”了。</p>
]]></content>
      <categories>
        <category>node</category>
      </categories>
      <tags>
        <tag>进阶</tag>
      </tags>
  </entry>
  <entry>
    <title>前端错误监控</title>
    <url>/blog/%E5%89%8D%E7%AB%AF%E9%94%99%E8%AF%AF%E7%9B%91%E6%8E%A7/</url>
    <content><![CDATA[<h2 id="常见错误类型"><a href="#常见错误类型" class="headerlink" title="常见错误类型"></a>常见错误类型</h2><table>
<thead>
<tr>
<th>错误</th>
<th>解释</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>SyntaxError</td>
<td>解析时发生语法错误</td>
<td>const x</td>
</tr>
<tr>
<td>TypeError</td>
<td>值不是所期待的类型</td>
<td>const person &#x3D; 1; person.name</td>
</tr>
<tr>
<td>ReferenceError</td>
<td>引用未声明的变量</td>
<td>x</td>
</tr>
<tr>
<td>RangeError</td>
<td>一个值不在其所允许的范围中</td>
<td>new Array(-1)</td>
</tr>
<tr>
<td>ResourceError</td>
<td>资源加载错误</td>
<td>new Image().src &#x3D; ‘&#x2F;remote&#x2F;null.jpg’</td>
</tr>
<tr>
<td>HttpError</td>
<td>http 请求错误</td>
<td>fetch(‘&#x2F;remote&#x2F;null’)</td>
</tr>
</tbody></table>
<span id="more"></span>

<h2 id="如何捕获错误"><a href="#如何捕获错误" class="headerlink" title="如何捕获错误"></a>如何捕获错误</h2><h3 id="try-catch"><a href="#try-catch" class="headerlink" title="try&#x2F;catch"></a>try&#x2F;catch</h3><p>能够捕获常规运行时错误，语法错误和异步错误无法捕获</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规运行时错误，可以捕获 ✅</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(notdefined);</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误，不能捕获 ❌</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> notdefined,</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>, e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步错误，不能捕获 ❌</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="variable language_">console</span>.<span class="title function_">log</span>(notdefined);</span><br><span class="line">  &#125;, <span class="number">0</span>)</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="window-onerror"><a href="#window-onerror" class="headerlink" title="window.onerror"></a>window.onerror</h3><blockquote>
<p>混合事件 GlobalEventHandlers 的 onerror 属性是用于处理 error 的事件<br>Error 事件的事件处理程序，在各种目标对象的不同类型错误被触发：</p>
</blockquote>
<blockquote>
<ul>
<li>当 JavaScript 运行时错误（包括语法错误）发生时，window 会触发一个 ErrorEvent 接口的 error 事件，并执行 window.onerror()。</li>
<li>当一项资源（如&lt;img&gt;或&lt;script&gt;）加载失败，加载资源的元素会触发一个 Event 接口的 error 事件，并执行该元素上的 onerror() 处理函数。这些 error 事件不会向上冒泡到 window，不过（至少在 Firefox 中）能被单一的 window.addEventListener 捕获。</li>
</ul>
</blockquote>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123; ... &#125;</span><br></pre></td></tr></table></figure>

<p>函数参数：</p>
<ul>
<li>message：错误信息（字符串）。可用于 HTML onerror&#x3D;””处理程序中的 event。</li>
<li>source：发生错误的脚本 URL（字符串）</li>
<li>lineno：发生错误的行号（数字）</li>
<li>colno：发生错误的列号（数字）</li>
<li>error：Error 对象（对象）</li>
</ul>
<p>若该函数返回 true，则阻止执行默认事件处理函数。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 常规运行时错误，可以捕获 ✅</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(notdefined);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 语法错误，不能捕获 ❌</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> notdefined,</span><br><span class="line"></span><br><span class="line"><span class="comment">// 异步错误，可以捕获 ✅</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(notdefined);</span><br><span class="line">&#125;, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 资源错误，不能捕获 ❌</span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="variable language_">window</span>.<span class="property">onerror</span> = <span class="keyword">function</span>(<span class="params">message, source, lineno, colno, error</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;捕获到异常：&#x27;</span>,&#123;message, source, lineno, colno, error&#125;);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"><span class="language-xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://unknown/image/null.png&quot;</span>&gt;</span></span></span><br><span class="line"><span class="language-xml"></span></span><br></pre></td></tr></table></figure>

<h3 id="window-addEventListener"><a href="#window-addEventListener" class="headerlink" title="window.addEventListener"></a>window.addEventListener</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">// 图片、script、css加载错误，都能被捕获 ✅</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;error&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, error)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">  )</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;https://unknown/image/null.png&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">&quot;https://unknown/foundnull.js&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">href</span>=<span class="string">&quot;https://unknown/foundnull.css&quot;</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">// new Image错误，不能捕获 ❌</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;error&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, error)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">  )</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="keyword">new</span> <span class="title class_">Image</span>().<span class="property">src</span> = <span class="string">&quot;https://unknown/image/null.png&quot;</span></span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// fetch错误，不能捕获 ❌</span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(</span></span><br><span class="line"><span class="language-javascript">    <span class="string">&quot;error&quot;</span>,</span></span><br><span class="line"><span class="language-javascript">    <span class="function">(<span class="params">error</span>) =&gt;</span> &#123;</span></span><br><span class="line"><span class="language-javascript">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, error)</span></span><br><span class="line"><span class="language-javascript">    &#125;,</span></span><br><span class="line"><span class="language-javascript">    <span class="literal">true</span></span></span><br><span class="line"><span class="language-javascript">  )</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="line"><span class="language-javascript">  <span class="title function_">fetch</span>(<span class="string">&quot;https://unknown/test&quot;</span>)</span></span><br><span class="line"><span class="language-javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="异步错误"><a href="#异步错误" class="headerlink" title="异步错误"></a>异步错误</h3><p>如果使用 try&#x2F;catch 能捕获 await 的错误<br>普通 Promise 错误 使用 catch</p>
<h3 id="全局捕获错误-unhandledrejection"><a href="#全局捕获错误-unhandledrejection" class="headerlink" title="全局捕获错误 - unhandledrejection"></a>全局捕获错误 - unhandledrejection</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 全局统一处理Promise</span></span><br><span class="line"><span class="variable language_">window</span>.<span class="title function_">addEventListener</span>(<span class="string">&quot;unhandledrejection&quot;</span>, <span class="keyword">function</span> (<span class="params">e</span>) &#123;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&quot;捕获到异常：&quot;</span>, e)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="title function_">fetch</span>(<span class="string">&quot;https://unknown/test&quot;</span>)</span><br></pre></td></tr></table></figure>

<h3 id="Vue-的错误"><a href="#Vue-的错误" class="headerlink" title="Vue 的错误"></a>Vue 的错误</h3><p>vue 的错误会被 vue 自动捕获，并且抛给 Vue.config.errorHandler。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 全局捕获Vue错误，直接扔出给onerror处理</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="title class_">Vue</span>.<span class="property">config</span>.<span class="property">errorHandler</span> = <span class="keyword">function</span> (<span class="params">err</span>) &#123;</span><br><span class="line">  <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">throw</span> err</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="React-错误"><a href="#React-错误" class="headerlink" title="React 错误"></a>React 错误</h3><p>react 通过 componentDidCatch，声明一个错误边界的组件</p>
<h2 id="数据上报接口"><a href="#数据上报接口" class="headerlink" title="数据上报接口"></a>数据上报接口</h2><p>使用 1*1 像素的 gif 图片进行上报，有以下几点好处</p>
<ul>
<li>不会阻塞页面渲染</li>
<li>图片天然跨域</li>
<li>不会携带 Cookie</li>
<li>不需等待服务器返回数据</li>
<li>gif 图片所需流量最小</li>
</ul>
<p>但数据太大，最好还是用 post</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title>原型与原型链</title>
    <url>/blog/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
    <content><![CDATA[<h2 id="原型与原型链"><a href="#原型与原型链" class="headerlink" title="原型与原型链"></a>原型与原型链</h2><p><strong>实例与构造函数原型之间有直接的联系，但实例与构造函数之间没有。</strong></p>
<p>每个函数都有一个属性，就是 prototype，函数的 prototype 指向了一个对象，这个对象就是调用该构造函数创建的<strong>实例</strong>的原型。</p>
<p>可以这么理解：每一个 JavaScript 对象(null 除外)在创建的时候就会与之关联另一个对象，这个对象就是我们所说的原型，每一个对象都会从原型“继承”属性。实例 person 与 Person.prototype 之间的关系通过 <strong>proto</strong> 连接这是每一个 JavaScript 对象(除了 null )都具有的一个属性，叫<strong>proto</strong>，这个属性会指向该对象的原型。</p>
<p><img data-src="/blog/./%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image1.png" alt="原型"></p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">__proto__</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/blog/./%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image2.png" alt="原型"></p>
<p>每个原型都有一个 <strong>constructor</strong> 属性指向关联的构造函数。</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">Person</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p><img data-src="/blog/./%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image3.png" alt="原型"></p>
<p>原型也是一个对象，那就可以通过 Object 构造函数生成，所以</p>
<p><img data-src="/blog/./%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image4.png" alt="原型"></p>
<p>Object.prototype.<strong>proto</strong> 的值为 null 跟 Object.prototype 没有原型，其实表达了一个意思。</p>
<h3 id="一些细节"><a href="#一些细节" class="headerlink" title="一些细节"></a>一些细节</h3><p><img data-src="/blog/./%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image5.png" alt="原型"></p>
<h3 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a>constructor</h3><figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">Person</span>(<span class="params"></span>) &#123;&#125;</span><br><span class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> <span class="title class_">Person</span>()</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(person.<span class="property">constructor</span> === <span class="title class_">Person</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>

<p>当获取 person.constructor 时，其实 person 中并没有 constructor 属性,当不能读取到 constructor 属性时，会从 person 的原型也就是 Person.prototype 中读取，正好原型中有该属性，所以：</p>
<figure class="highlight jsx"><table><tr><td class="code"><pre><span class="line">person.<span class="property">constructor</span> === <span class="title class_">Person</span>.<span class="property"><span class="keyword">prototype</span></span>.<span class="property">constructor</span></span><br></pre></td></tr></table></figure>

<h3 id="proto"><a href="#proto" class="headerlink" title="proto"></a><strong>proto</strong></h3><p>绝大部分浏览器都支持这个非标准的方法访问原型，然而它并不存在于 Person.prototype 中，实际上，它是来自于 Object.prototype ，与其说是一个属性，不如说是一个 getter&#x2F;setter，当使用 obj.<strong>proto</strong> 时，可以理解成返回了 Object.getPrototypeOf(obj)。</p>
<h3 id="真的是继承吗？"><a href="#真的是继承吗？" class="headerlink" title="真的是继承吗？"></a>真的是继承吗？</h3><p>最后是关于继承，前面我们讲到“每一个对象都会从原型‘继承’属性”，实际上，继承是一个十分具有迷惑性的说法，引用《你不知道的 JavaScript》中的话，就是：</p>
<p>继承意味着复制操作，然而 JavaScript 默认并不会复制对象的属性，相反，JavaScript 只是在两个对象之间创建一个关联，这样，一个对象就可以通过委托访问另一个对象的属性和函数，所以与其叫继承，委托的说法反而更准确些。</p>
<h3 id="Function-proto-Function-prototype"><a href="#Function-proto-Function-prototype" class="headerlink" title="Function.proto &#x3D;&#x3D;&#x3D; Function.prototype"></a>Function.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Function.prototype</h3><p>Function 作为一个内置对象，是运行前就已经存在的东西，所以根本就不会根据自己生成自己，就是先有的 Function，然后实现上把原型指向了 Function.prototype，但是我们不能倒过来推测因为 Function.<strong>proto</strong> &#x3D;&#x3D;&#x3D; Function.prototype，所以 Function 调用了自己生成了自己。</p>
<h3 id="完整的原型链"><a href="#完整的原型链" class="headerlink" title="完整的原型链"></a>完整的原型链</h3><p><img data-src="/blog/./%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/image6.png" alt="原型"></p>
<p><strong>什么是原型链？</strong></p>
<p>当对象查找一个属性的时候，如果没有在自身找到，那么就会查找自身的原型，如果原型还没有找到，那么会继续查找原型的原型，直到找到 Object.prototype 的原型时，此时原型为 null，查找停止。 这种通过<strong>原型链接的逐级向上的查找链</strong>被称为原型链</p>
<p><strong>什么是原型继承？</strong></p>
<p>一个对象可以使用另外一个对象的属性或者方法，就称之为继承。具体是通过将这个对象的原型设置为另外一个对象，这样根据原型链的规则，如果查找一个对象属性且在自身不存在时，就会查找另外一个对象，相当于一个对象可以使用另外一个对象的属性和方法了。</p>
<p>使用 <strong>Object.prototype.toString.call()</strong> 判断数据类型</p>
<p><strong>proto</strong> 与内部的 <strong>[[Prototype]] 不一样</strong>。</p>
<p><strong>proto</strong> 是 <strong>[[Prototype]]</strong> 的 getter&#x2F;setter。</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>性能优化的一般性原则</title>
    <url>/blog/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96%E7%9A%84%E4%B8%80%E8%88%AC%E6%80%A7%E5%8E%9F%E5%88%99/</url>
    <content><![CDATA[<h1 id="性能优化的一般性原则"><a href="#性能优化的一般性原则" class="headerlink" title="性能优化的一般性原则"></a>性能优化的一般性原则</h1><h2 id="一般性原则"><a href="#一般性原则" class="headerlink" title="一般性原则"></a>一般性原则</h2><h3 id="依据数据而不是凭空猜测"><a href="#依据数据而不是凭空猜测" class="headerlink" title="依据数据而不是凭空猜测"></a>依据数据而不是凭空猜测</h3><p>这是前端性能优化的第一原则，当我们怀疑前端性能有问题的时候，应该通过测试、浏览器开发者工具、性能分析工具来分析出哪里有问题，有的放矢，而不是凭感觉、撞运气。一个前端页面有了性能问题，瓶颈有可能是 JavaScript 执行时间过长，有可能是网络请求过多或请求资源过大，有可能是 DOM 操作频繁导致重排重绘，大方向的定位可以使用浏览器开发者工具的 Performance 面板来定位，针对具体的代码块，可以使用 console.time 和 console.timeEnd 来分析执行时间。</p>
<h3 id="忌过早优化"><a href="#忌过早优化" class="headerlink" title="忌过早优化"></a>忌过早优化</h3><blockquote>
<p>The real problem is that programmers have spent far too much time worrying about efficiency in the wrong places and at the wrong times; premature optimization is the root of all evil (or at least most of it) in programming.</p>
</blockquote>
<p>我并不十分清楚 Donald Knuth 说出这句名言的上下文环境，但我自己是十分认同这个观念的。在我的工作环境（以及典型的互联网应用开发）与编程模式下，追求的是快速的迭代与试错，过早的优化往往是无用功。而且，过早的优化很容易拍脑袋，优化的点往往不是真正的性能瓶颈。</p>
<h3 id="忌过度优化"><a href="#忌过度优化" class="headerlink" title="忌过度优化"></a>忌过度优化</h3><blockquote>
<p>As performance is part of the specification of a program – a program that is unusably slow is not fit for purpose</p>
</blockquote>
<p>性能优化的目标是追求合适的性价比。</p>
<p>在不同的阶段，我们对系统的性能会有一定的要求，比如吞吐量要达到多少多少。如果达不到这个指标，就需要去优化。如果能满足预期，那么就无需花费时间精力去优化，比如只有几十个人使用的内部系统，就不用按照十万在线的目标去优化。</p>
<p>而且，一些优化方法是“有损”的，可能会对代码的可读性、可维护性有副作用。这个时候，就更不能过度优化。</p>
<h3 id="深入理解业务"><a href="#深入理解业务" class="headerlink" title="深入理解业务"></a>深入理解业务</h3><p>代码是服务于业务的，也许是服务于最终用户，也许是服务于其他程序员。不了解业务，很难理解系统的流程，很难找出系统设计的不足之处。</p>
<h3 id="性能优化是持久战"><a href="#性能优化是持久战" class="headerlink" title="性能优化是持久战"></a>性能优化是持久战</h3><p>当核心业务方向明确之后，就应该开始关注性能问题，当项目上线之后，更应该持续的进行性能检测与优化。</p>
<p>现在的互联网产品，不再是一锤子买卖，在上线之后还需要持续的开发，用户的涌入也会带来性能问题。因此需要自动化的检测性能问题，保持稳定的测试环境，持续的发现并解决性能问题，而不是被动地等到用户的投诉。</p>
<h3 id="选择合适的衡量指标、测试用例、测试环境"><a href="#选择合适的衡量指标、测试用例、测试环境" class="headerlink" title="选择合适的衡量指标、测试用例、测试环境"></a>选择合适的衡量指标、测试用例、测试环境</h3><p>正因为性能优化是一个长期的行为，所以需要固定衡量指标、测试用例、测试环境，这样才能客观反映性能的实际情况，也能展现出优化的效果。</p>
<p>衡量性能有很多指标，比如系统响应时间、系统吞吐量、系统并发量。不同的系统核心指标是不一样的，首先要明确本系统的核心性能诉求，固定测试用例；其次也要兼顾其他指标，不能顾此失彼。</p>
<p>测试环境也很重要，有一次突然发现我们的 QPS 高了许多，但是程序压根儿没优化，查了半天，才发现是换了一个更牛逼的物理机做测试服务器。</p>
<h2 id="性能优化的层次"><a href="#性能优化的层次" class="headerlink" title="性能优化的层次"></a>性能优化的层次</h2><p>可以分为需求阶段，设计阶段，实现阶段；越上层的阶段优化效果越明显，同时也更需要对业务、需求的深入理解。</p>
<h3 id="需求阶段"><a href="#需求阶段" class="headerlink" title="需求阶段"></a>需求阶段</h3><p>程序员的需求可能来自 PM、UI 的业务需求（或者说是功能性需求），也可能来自 Team Leader 的需求。当我们拿到一个需求的时候，首先需要的是思考、讨论需求的合理性，而不是立刻去设计、去编码。</p>
<p>需求是为了解决某个问题，<strong>问题是本质，需求是解决问题的手段</strong>。那么需求是否能否真正的解决问题，程序员也得自己去思考，产品经理（特别是知道一点技术的产品经理）的某个需求可能只是某个问题的解决方案，他认为这个方法可以解决他的问题，于是把解决方案当成了需求，而不是真正的问题。</p>
<p>需求讨论的前提对业务的深入了解，如果不了解业务，根本没法讨论。即使需求已经实现了，当我们发现有性能问题的时候，首先也可以从需求出发。</p>
<p>需求分析对性能优化有什么帮助呢，第一，为了达到同样的目的，解决同样问题，也许可以有性能更优（消耗更小）的办法。这种优化是无损的，即不改变需求本质的同时，又能达到性能优化的效果；第二种情况，有损的优化，即在不明显影响用户的体验，稍微修改需求、放宽条件，就能大大解决性能问题。PM 退步一小步，程序前进一大步。</p>
<p>需求讨论也有助于设计时更具扩展性，应对未来的需求变化。</p>
<h3 id="设计阶段"><a href="#设计阶段" class="headerlink" title="设计阶段"></a>设计阶段</h3><p>高手都是花 80% 时间思考，20% 时间实现；新手写起代码来很快，但后面是无穷无尽的修 bug</p>
<p>设计的概念很宽泛，包括架构设计、技术选型、接口设计等等。架构设计约束了系统的扩展、技术选型决定了代码实现。编程语言、框架都是工具，不同的系统、业务需要选择适当的工具集。如果设计的时候做的不够好，那么后面就很难优化，甚至需要推到重来。</p>
<h3 id="实现阶段"><a href="#实现阶段" class="headerlink" title="实现阶段"></a>实现阶段</h3><p>实现是把功能翻译成代码的过程，这个层面的优化，主要是针对一个调用流程，一个函数，一段代码的优化。各种 profile 工具也主要是在这个阶段生效。除了静态的代码的优化，还有编译时优化，运行时优化。后二者要求就很高了，程序员可控性较弱。</p>
<p>代码层面，造成性能瓶颈的原因通常是高频调用的函数、或者单次消耗非常高的函数、或者二者的结合。</p>
<h2 id="一般性方法"><a href="#一般性方法" class="headerlink" title="一般性方法"></a>一般性方法</h2><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><blockquote>
<p>没有什么性能问题是缓存解决不了的，如果有，那就再加一级缓存</p>
</blockquote>
<p>缓存的本质是加速访问，访问的数据要么是其他数据的副本 – 让数据离用户更近；要么是之前的计算结果 – 避免重复计算.</p>
<p>缓存需要用空间换时间，在缓存空间有限的情况下，需要优秀的置换换算来保证缓存有较高的命中率。</p>
<h3 id="数据的缓存"><a href="#数据的缓存" class="headerlink" title="数据的缓存"></a>数据的缓存</h3><p>这是我们最常见的缓存形式，将数据缓存在离使用者更近的地方。比如操作系统中的 CPU cache、disk cache。对于一个 web 应用，前端会有浏览器缓存，有 CDN，有反向代理提供的静态内容缓存；后端则有本地缓存、分布式缓存。</p>
<p>数据的缓存，很多时候是设计层面的考虑。</p>
<p>对于数据缓存，需要考虑的是缓存一致性问题。对于分布式系统中有强一致性要求的场景，可行的解决办法有 lease，版本号。</p>
<h3 id="计算结果的缓存"><a href="#计算结果的缓存" class="headerlink" title="计算结果的缓存"></a>计算结果的缓存</h3><p>对于消耗较大的计算，可以将计算结果缓存起来，下次直接使用。</p>
<p>我们知道，对递归代码的一个有效优化手段就是缓存中间结果，lookup table，避免了重复计算。python 中的 method cache 就是这种思想.</p>
<p>对于可能重复创建、销毁，且创建销毁代价很大的对象，比如进程、线程，也可以缓存，对应的缓存形式如单例、资源池（连接池、线程池）。</p>
<p>对于计算结果的缓存，也需要考虑缓存失效的情况，对于 pure function，固定的输入有固定的输出，缓存是不会失效的。</p>
<h3 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h3><p>一个人干不完的活，那就找两个人干。并发既增加了系统的吞吐，又减少了用户的平均等待时间。</p>
<h3 id="惰性"><a href="#惰性" class="headerlink" title="惰性"></a>惰性</h3><p>将计算推迟到必需的时刻，这样很可能避免了多余的计算，甚至根本不用计算。</p>
<p>CopyOnWrite、Dirty flag</p>
<h3 id="批量，合并"><a href="#批量，合并" class="headerlink" title="批量，合并"></a>批量，合并</h3><p>前端开发中经常会有资源的压缩和合并。</p>
<p>当涉及到网络请求的时候，网络传输的时间可能远大于请求的处理时间，因此合并网络请求就很有必要。</p>
<h3 id="更高效的实现"><a href="#更高效的实现" class="headerlink" title="更高效的实现"></a>更高效的实现</h3><p>同一个算法，肯定会有不同的实现，那么就会有不同的性能；有的实现可能是时间换空间，有的实现可能是空间换时间，那么就需要根据自己的实际情况权衡。</p>
<p>程序员都喜欢早轮子，用于练手无可厚非，但在项目中，使用成熟的、经过验证的轮子往往比自己造的轮子性能更好。当然不管使用别人的轮子，还是自己的工具，当出现性能的问题的时候，要么优化它，要么替换掉他。</p>
<h3 id="缩小解空间"><a href="#缩小解空间" class="headerlink" title="缩小解空间"></a>缩小解空间</h3><p>缩小解空间的意思是说，在一个更小的数据范围内进行计算，而不是遍历全部数据。最常见的就是索引，通过索引，能够很快定位数据，对数据库的优化绝大多数时候都是对索引的优化。</p>
<p>如果有本地缓存，那么使用索引也会大大加快访问速度。不过，索引比较适合读多写少的情况，毕竟索引的构建也是需有消耗的。</p>
<h2 id="性能优化与代码质量"><a href="#性能优化与代码质量" class="headerlink" title="性能优化与代码质量"></a>性能优化与代码质量</h2><p>衡量代码质量的标准是可读性、可维护性、可扩展性，但性能优化有可能会违背这些特性，比如为了屏蔽实现细节与使用方式，我们会可能会加入接口层（虚拟层），这样可读性、可维护性、可扩展性会好很多，但是额外增加了一层函数调用，如果这个地方调用频繁，那么也是一笔开销；又如前面提到的 C 扩展，也是会降低可维护性、</p>
<p>这种有损代码质量的优化，应该放到最后，不得已而为之，同时写清楚注释与文档。</p>
<p>为了追求可扩展性，我们经常会引入一些设计模式，如状态模式、策略模式、模板方法、装饰器模式等，但这些模式不一定是性能友好的。所以，为了性能，我们可能写出一些反模式的、定制化的、不那么优雅的代码，这些代码其实是脆弱的，需求的一点点变动，对代码逻辑可能有至关重要的影响，所以还是回到前面所说，不要过早优化，不要过度优化。<br>​</p>
<p>‍</p>
]]></content>
      <categories>
        <category>性能优化</category>
      </categories>
  </entry>
  <entry>
    <title>网络测速</title>
    <url>/blog/%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/</url>
    <content><![CDATA[<h2 id="前端如何测试网络的速度？"><a href="#前端如何测试网络的速度？" class="headerlink" title="前端如何测试网络的速度？"></a>前端如何测试网络的速度？</h2><p>B 站视频播放时有一个自动根据网络环境调整分辨率的功能，想了解如何测速<br><img data-src="/blog/./%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/b.png" alt="b站"></p>
<p>然后我找了下面的方法测速</p>
<h3 id="ajax-请求"><a href="#ajax-请求" class="headerlink" title="ajax 请求"></a>ajax 请求</h3><p>利用 XMLHttpRequest 请求返回的 Content-length，和请求所需时间求得下载速度</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getSpeed</span> = (<span class="params">url</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="variable language_">window</span>.<span class="property">performance</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">const</span> xhr = <span class="keyword">new</span> <span class="title class_">XMLHttpRequest</span>()</span><br><span class="line">    xhr.<span class="title function_">open</span>(<span class="string">&quot;GET&quot;</span>, url)</span><br><span class="line">    xhr.<span class="property">onreadystatechange</span> = <span class="keyword">function</span> (<span class="params"></span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (xhr.<span class="property">readyState</span> === <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">const</span> time = (<span class="variable language_">window</span>.<span class="property">performance</span>.<span class="title function_">now</span>() - start) / <span class="number">1000</span></span><br><span class="line">        <span class="keyword">const</span> size = xhr.<span class="title function_">getResponseHeader</span>(<span class="string">&quot;Content-Length&quot;</span>) / <span class="number">1024</span></span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(time, size)</span><br><span class="line">        <span class="title function_">resolve</span>(size / time)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    xhr.<span class="title function_">send</span>()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="title function_">getSpeed</span>(<span class="string">&quot;./worker.js&quot;</span>).<span class="title function_">then</span>(<span class="function">(<span class="params">speed</span>) =&gt;</span> <span class="variable language_">console</span>.<span class="title function_">log</span>(speed))</span><br></pre></td></tr></table></figure>

<p>请求我本地的文件测得速度：<br><img data-src="/blog/./%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/speed.png" alt="speed"></p>
<h3 id="Image-对象-onload"><a href="#Image-对象-onload" class="headerlink" title="Image 对象 onload"></a>Image 对象 onload</h3><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">getSpeed</span> = (<span class="params">url, fileSize</span>) =&gt; &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Promise</span>(<span class="function">(<span class="params">resolve</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> start = <span class="variable language_">window</span>.<span class="property">performance</span>.<span class="title function_">now</span>()</span><br><span class="line">    <span class="keyword">const</span> img = <span class="keyword">new</span> <span class="title class_">Image</span>()</span><br><span class="line">    img.<span class="property">src</span> = url</span><br><span class="line">    img.<span class="property">onload</span> = <span class="function">(<span class="params">e</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">const</span> time = (<span class="variable language_">window</span>.<span class="property">performance</span>.<span class="title function_">now</span>() - start) / <span class="number">1000</span></span><br><span class="line">      <span class="title function_">resolve</span>(fileSize / time)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是要注意如果请求服务器的文件，建立请求也需要消耗时间，最好是多次请求取平均值。</p>
<h3 id="还有一个-downlink"><a href="#还有一个-downlink" class="headerlink" title="还有一个 downlink"></a>还有一个 downlink</h3><p><img data-src="/blog/./%E7%BD%91%E7%BB%9C%E6%B5%8B%E9%80%9F/downlink.png" alt="downlink"><br>downlink 的单位是 mbps, 所以要转化成 kb&#x2F;s</p>
]]></content>
      <categories>
        <category>js</category>
      </categories>
  </entry>
  <entry>
    <title>虚假的洗牌算法</title>
    <url>/blog/%E8%99%9A%E5%81%87%E7%9A%84%E6%B4%97%E7%89%8C%E7%AE%97%E6%B3%95/</url>
    <content><![CDATA[<h2 id="虚假的洗牌算法"><a href="#虚假的洗牌算法" class="headerlink" title="虚假的洗牌算法"></a>虚假的洗牌算法</h2><p>最常见的：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="title function_">shuffle</span> = (<span class="params">list</span>) =&gt; list.<span class="title function_">sort</span>(<span class="function">(<span class="params">x, y</span>) =&gt;</span> <span class="title class_">Math</span>.<span class="title function_">random</span>() - <span class="number">0.5</span>)</span><br></pre></td></tr></table></figure>

<p>可这并不合理，对于这个数组：[1,2,3,4,5]，每个数字出现在每个位置的概率应该是相同的。然而使用以上算法，1 出现在 index&#x3D;4 位置的概率 与 4 出现在 index&#x3D;4 的概率并不相同。</p>
<h2 id="真正的洗牌算法"><a href="#真正的洗牌算法" class="headerlink" title="真正的洗牌算法"></a>真正的洗牌算法</h2><p><a href="https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle">Fisher–Yates shuffle</a></p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> nums = <span class="title class_">Array</span>(<span class="number">54</span>)</span><br><span class="line">  .<span class="title function_">fill</span>(<span class="literal">undefined</span>)</span><br><span class="line">  .<span class="title function_">map</span>(<span class="function">(<span class="params">_, index</span>) =&gt;</span> index)</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 洗牌算法</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums 数组</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">FYSufffle</span>(<span class="params">nums</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> randNums = <span class="title class_">Array</span>.<span class="title function_">from</span>(nums)</span><br><span class="line">  <span class="keyword">let</span> len = nums.<span class="property">length</span></span><br><span class="line">  <span class="keyword">while</span> (len &gt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> rand = <span class="title class_">Math</span>.<span class="title function_">floor</span>(<span class="title class_">Math</span>.<span class="title function_">random</span>() * len)</span><br><span class="line">    len--</span><br><span class="line">    <span class="comment">// 交换</span></span><br><span class="line">    ;[randNums[rand], randNums[len]] = [randNums[len], randNums[rand]]</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> randNums</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="title class_">FYSufffle</span>(nums))</span><br></pre></td></tr></table></figure>

<p>以上。</p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
  </entry>
</search>
